{
 "crn_code": "22025",
 "season": "201401",
 "legacy_coursetable_course_id": 26380,
 "enrollment": {
  "enrolled": 31,
  "responses": null,
  "declined": null,
  "no response": null
 },
 "ratings": [
  {
   "question_id": "YC005",
   "question_text": "Overall, how would you rate the workload of this course in comparison to other Yale courses you have taken?",
   "options": [
    "Much Less",
    "Less",
    "Same",
    "Greater",
    "Much Greater"
   ],
   "data": [
    0,
    2,
    1,
    12,
    9
   ]
  },
  {
   "question_id": "YC006",
   "question_text": "What is your overall assessment of this course?",
   "options": [
    "Poor",
    "Below Average",
    "Good",
    "Very Good",
    "Excellent"
   ],
   "data": [
    0,
    1,
    3,
    6,
    13
   ]
  },
  {
   "question_id": "YC007",
   "question_text": "Do you expect to use this class for credit toward your major, or toward a pre-professional program?",
   "options": [
    "Yes",
    "No"
   ],
   "data": [
    23,
    1
   ]
  }
 ],
 "narratives": [
  {
   "question_id": "YC004",
   "question_text": "How would you summarize ECON 110 05 for a fellow student? Would you recommend ECON 110 05 to another student? Why or why not?",
   "comments": [
    "CPSC 421 is the best CS course that I have taken in my four years at Yale. In the course of building a full compiler over the course of the semester, you learn so many things (from regular expressions to assembly language), and you also learn so much about programming, all of which is useful whether you ever make another compiler or not. The first 4 problem sets are pretty easy, the fifth one is long but not too difficult, but the 6th one is very long and very difficult. For the sixth problem set, you work on one of three projects (ITreeGen, CodeGen, and RegAlloc) and have to interface your project with the other two projects, built by other students. Usually getting started early is a good thing, and I don't discourage it, but since there won't be any working modules from the other two groups at first, it will be incredibly difficult to even figure out what you should be doing, much less debug your code. I would recommend CodeGen (which I did) since it's the best introduction to assembly code. For assignment 7 you can do one of the other two projects or something different (from a list of projects), but if you choose one of the other two projects, it should be pretty easy after having completed Assignment 6.",
    "Compilers is probably my favorite computer science course out of the ones that I've taken. The solution for how a compiler is built is very eloquent and interesting to learn about. Professor Shao is one of the top professors in the computer science department. The workload for the class is relatively moderate (all but two of the psets can be completed in a night).",
    "Definitely take the class if you are interested in compilers or even if you generally want to better understand how your programs work",
    "This class is pretty work intensive. The easiest (but least useful in preparing for the one midterm at the end of the semester) choice for assignment 6 is regalloc. Class can be boring, though Zhong Shao is a really funny, extremely smart guy. Go to lecture awake and don't use your laptop during class. CS majors should know how compilers work, and this is arguably one of the better CS electives, so take it if you've got time for it.",
    "It's well taught and not as hard as I thought it would be, but make sure you're really interested in compilers before you start as it can get a bit dry.",
    "Definitely take this course. The material is amazing, and the assignments are super, super cool. Keeping pace with the lectures is difficult if your tendency is to do the assignments close to the due date - you will do much better in the course if you start the assignments as soon as they are released, because the lectures will correspond more closely to them (the pace of the lectures moves very quickly w.r.t. the assignments that follow). The documentation is poor, so you might need to spend some time in office hours making heads or tails of what you're being asked, but the assignments themselves are great. Lectures are super clear, but find out if you'd be permitted to record them, because they correspond closely with the assignments (the ideal would almost be to hop back and forth between the lecture and assignment, listening to a concept and then implementing it). Be prepared to put in a lot of work, but this course is worth it!",
    "There's an article online by Steve Yegge explaining why compilers is the most important class to take as a computer science major. The one reason he's missing (in my opinion) is that they're just plain *cool*. You write a compiler for a toy language called Tiger in Standard ML, which will be immediately familiar to anyone who's taken one of Professor Hudak's courses in Haskell (the better of the two). You should take this class. It's not as hard as anyone says it is, it's more important than most people realize, and it's a *lot* of fun.",
    "This is an excellent class. You learn how text gets translated into instructions your computer runs through a series of small, simple transformations, and it's quite magical. Assignment 5 and 6 and hard, but are all manageable. Shao is a good lecturer (don't skip!), and the textbook is very helpful. Every CS major should take this!",
    "Yes, take this class. You will learn a lot about compilers and interpreters and Zhong Shao is a great professor.",
    "Take with professor Shao, you will not like ML, but it won't be so bad.",
    "Best computer science class I've taken at Yale, take it your junior year if you can. Reasonable but nontrivial amount of work",
    "Compilers was the most fun I have had programming since 201. The entire class is based around Andrew Appel's book Modern Compiler Implementation in SML, which is truly a fantastic text. It is augmented by Professor Shao's deep understanding and appreciation for the complexities of building compilers, which adds another level of depth to the class. The class was programming intensive, somewhere in between 223 and 323 (taught by Professor Eisenstat) in difficulty. Although not for those who detested Scheme in 201, Standard ML was a joy to work with in these assignments. It's a perfect language for this purpose, with a lot of recursive datatypes, and the more you learn about compiler implementation the more you scratch your head and wonder how the sml interpreter works. The class was taught with 6 assignments, each one involving building a compiler. The first one was a small interpreter for an abstract syntax tree, just to get a feel for Standard ML. The next four were lexing, parsing, absyn generation, and type-checking (difficult!). These were progressively more difficult, and built off the previous assignments, so you wanted to make sure you got them right. The last two assignments were tying it all together, where we built one third of the last stage of the compiler (ITree Construction, Code Generation, or Register Allocation), and combined that with other classmate's modules. The last assignment was to do a module we hadn't done already, or implement an advanced feature detailed in the book (closures, object-oriented tiger, garbage collection etc).",
    "You write a compiler for a toy language called Tiger using a really cool functional programming language called ML. (Despite being an awesome language, ML's toolchain is not great; e.g. I went through the semester without using a debugger, not out of arrogance\/foolishness but because there wasn't one.) Each assignment is to complete a different stage of the compiler (lexing, parsing, type-checking, intermediate code generation, assembly code generation, register allocation, etc.), and there is a final project to do whatever you'd like (garbage collection, optimization, etc.). Compilers is not really a difficult course; it assumes a conceptual grounding in the basics of CS (you should be comfortable with the lecture material from CS223 and CS323, e.g. how the stack and heap work), but doesn't require you to do anything particularly clever. You never have to come up with your own algorithms, and the algorithms you do implement are not enlightening; mostly you are implementing feature after feature in a repetitive and straightforward fashion. There are a couple of mildly interesting implementation pitfalls that you are warned about in the book and in lecture, and for which solutions are already provided (e.g. how to type-check mutually recursive procedures, handle nested comments, break statements, etc.). The non-difficulty is enhanced by the fact that this year at least it seemed like only the public test cases were used to grade us... Still, I am glad I took the course. I did learn a lot about how compilers are implemented, and feel like I have a solid foundation to build on if I want to learn more advanced compiler-related material.",
    "Only if you're truly interested in how a compiler works. The workload is large and often unrewarding until the end of the project",
    "Yes I would recommend it"
   ]
  }
 ],
 "extras": {
  "subject": "CPSC",
  "number": "421",
  "section": 1
 }
}