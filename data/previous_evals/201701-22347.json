{
 "crn_code": "22347",
 "season": "201701",
 "legacy_coursetable_course_id": 41459,
 "enrollment": {
  "enrolled": 34,
  "responses": null,
  "declined": null,
  "no response": null
 },
 "ratings": [
  {
   "question_id": "YC402",
   "question_text": "Your level of engagement with the course was:",
   "options": [
    "very low",
    "low",
    "medium",
    "high",
    "very high"
   ],
   "data": [
    0,
    1,
    5,
    5,
    7
   ]
  },
  {
   "question_id": "YC404",
   "question_text": "What is your overall assessment of this course?",
   "options": [
    "poor",
    "fair",
    "good",
    "very good",
    "excellent"
   ],
   "data": [
    0,
    1,
    3,
    9,
    4
   ]
  },
  {
   "question_id": "YC405",
   "question_text": "The course was well organized to facilitate student learning.",
   "options": [
    "strongly disagree",
    "disagree",
    "neutral",
    "agree",
    "strongly agree"
   ],
   "data": [
    0,
    1,
    3,
    10,
    3
   ]
  },
  {
   "question_id": "YC406",
   "question_text": "I received clear feedback that improved my learning.",
   "options": [
    "strongly disagree",
    "disagree",
    "neutral",
    "agree",
    "strongly agree"
   ],
   "data": [
    1,
    0,
    7,
    6,
    3
   ]
  },
  {
   "question_id": "YC407",
   "question_text": "Relative to other courses you have taken at Yale, the level of intellectual challenge of this course was:",
   "options": [
    "much less",
    "less",
    "same",
    "greater",
    "much greater"
   ],
   "data": [
    0,
    0,
    1,
    11,
    5
   ]
  },
  {
   "question_id": "YC408",
   "question_text": "Relative to other courses you have taken at Yale, the workload of this course was:",
   "options": [
    "much less",
    "less",
    "same",
    "greater",
    "much greater"
   ],
   "data": [
    0,
    0,
    1,
    8,
    8
   ]
  }
 ],
 "narratives": [
  {
   "question_id": "YC401",
   "question_text": "What knowledge, skills, and insights did you develop by taking this course?",
   "comments": [
    "I learned how compilers work.",
    "Compilers is an essential course if you want to better understand programming languages in general, and how different features of a language are supported. Why can't a stack support higher order functions? Why do we need to be able to tell if an address is a pointer for garbage collection? Take compilers to find out!",
    "-Understand the basic responsibilities\/components of a modern compiler -Be able to implement many of these components from skeleton code -Understand more advanced ideas like garbage collection, functional languages, etc. -First class where I did significant functional programming (ML is cool!)",
    "I received a much stronger understanding of the compiler pipeline, including lexical analysis, semantic analysis, translation and code generation.",
    "All CS majors should take this course! From 421 you gain a real appreciation for the process behind how the code you write turns into actual machine instructions. You also get to learn the ins and outs of SML, a functional programming language that Zhong Shao helped develop while he was a PhD student.",
    "The course centers around building a complete compiler -- from the fronted pieces such as lexing and parsing, to the backend assembly code generation and register allocation. That being said, the most important lessons from the course are centered around programming languages themselves. By learning how a compiler works, you'll learn the nitty-gritty details of how programming languages work. For example, the class discusses object-oriented programming -- having learning how a compiler adds support for such features, it's trivial to go and understand what happens in an object-oriented programming language."
   ]
  },
  {
   "question_id": "YC403",
   "question_text": "What are the strengths and weaknesses of this course and how could it be improved?",
   "comments": [
    "The structure of this class was great, though I think the expectations for assignment 6 at the beginning with the \"dummy input\" deliverables could be clarified to make the whole assignment run more smoothly.",
    "The splitting of assignment 6 was useful for time purposes, but I think I could have learned more if the whole assignment was assigned to the whole course.",
    "I really liked how implementation focused the course was. I do think the beginning of the course was lighter before the course picked up in the middle of the semester, so the workload in the course was not very well balanced. Overall I think it's s solid course that taught me a lot.",
    "I think the class can pretty much stay as is.",
    "CPSC 421 has a lot of polish. It has clearly been adapted over many years to have the right amount of work, good lectures, and interesting topics.",
    "The psets are fun (though pset5 and pset6 are FAR more work than the first four). Unfortunately Prof. Shao's lectures can be quite dry and hard to follow. I also thought it was strange that our only test was at the end of the course. I think it would've been more helpful to have two midterms instead of one final test. That way we would've been forced to keep up with the material more throughout the semester instead of cramming at the end.",
    "The quality of the assignment specs could be improved especially for assignment 6 where the readme is severely outdated with in some cases outright false information..",
    "Strengths: The course centers around building a complete compiler. By actually sitting down and writing the code, you'll learn exactly how a compiler works. Weaknesses: Some of the lectures could have been more engaging. Not many students participated \/ asked questions... leaving Professor Shao to lecture on the subject for 1hr 15min."
   ]
  },
  {
   "question_id": "YC409",
   "question_text": "Would you recommend this course to another student? Please explain.",
   "comments": [
    "All CS majors owe it to themselves to take this course along with 422 (operating systems). Learning about compilers forces you to understand how programming languages work. After taking this course, you will find it much easier to pick up a new programming language. You also get to write nontrivial programs in a functional programming language (ML). As much as I love C, the beauty of type inference and pattern matching in ML makes C seem positively archaic. The course uses Standard ML, which is similar to OCaml, and once you've finished the course you'll be in a good position to pick up Haskell (much to Professor Shao's chagrin). If you can, start teaching yourself ML before the beginning of the semester. I would recommend Paulson's ML for the Working Programmer over Ullman's Elements of ML, even though the latter has a brilliant cover.",
    "This class isn't too workload heavy until assignment 5, where the assignments get much more involved. The class structure is really great, but make sure to go to lecture and make note of the key topics so that you won't be scrambling when the final comes. This class is very systems\/coding heavy, so be aware of that, but you do learn a ton about how to write a compiler\/how compilers work. Would definitely recommend to fellow CS majors.",
    "Yes.",
    "Taking compilers is a no brainer; just do it!!! Shao is extremely smart and he has worked on compilers for over twenty years. It shows in his lectures. Also, he is really funny and I greatly enjoyed going to lectures.",
    "I think this is one of the better higher-level electives in the department. If taught by Shao, it will pretty closely follow Appel's Modern Compiler Implementation in ML, which is a good book. All the assignments are based on projects from the book. So even if you are the type that does not thrive in lecture, the class is a good experience, because it forces you to familiarize with much of that textbook. The assignments are interesting, and each has its own distinctive flavor. You're always thinking about different stuff, which helps the relatively demanding workload (mainly ramps up at assignment 5, the type checker) feel less like tedium and more engaging. A lot of cool ideas! Also, a good way to do some \"serious\" functional programming (i.e. not 201).",
    "Any computer science major should take Shao's Compilers. Professor Shao has polished the course over many years to make the assignments reasonable and interesting. You build a compiler for a toy language (Tiger) using a real, functional language (Standard ML). The course is made much stronger by the fact that Professor Shao worked on building the SML-NJ compiler, did his PhD thesis on compilers, and really enjoys this topic. I would strongly recommend compilers to another student.",
    "My first CS course putting a multi-module program together (vs programming single programs in CS323). It is hard to learn SML (the language) and compiler design simultaneously. It moves quickly. I would recommend the instructor to have quizzes every week \/ every other week, since it would make the exam much more palatable. Studying for the exam was actually interesting and I grew more aware of how everything was fitting together, but I didn't really pay any attention to that material throughout the semester (since there were no quizzes until the end). I spent as much time on this as 323. as5 and as6 are definitely the hardest.",
    "Yes - learning how a compiler works is extremely rewarding.",
    "Compilers is pretty cool. The topic is really interesting, but Shao is not the most exciting lecturer, so many people chose to learn from the book instead. This is a shame because Shao is so knowledgeable (he did his PhD with the author of the textbook, and his work is cited multiple times inside it). The first couple psets are not too difficult, but it took me a bit to figure out SML and its cryptic error messages. (Overall SML is really cool, but sometimes getting through all the compilation errors is a pain. I'd recommend stubbing functions\/params you haven't written yet and making sure you can do a clean compile every line or so, because having multiple type errors at once can result in truly baffling warnings as the compiler tries to figure out what you meant.) Pset 5 is hard, mostly because it involves writing a significant amount of SML, and pset 6 is by far the hardest, so start early on those. I did garbage collection for assignment 7, which turned out to be harder than I thought, but was pretty cool when it finally sorta-worked, and grading was pretty lenient. The test is pretty hard and somewhat time constrained, so don't go in assuming you can figure out how the algorithms work on the fly because you'll run out of time. Overall, compilers is a bunch of work, but the material is really interesting so it's probably worth it.",
    "Yes, absolutely -- for two reasons: 1. Compilers involve fascinating algorithms -- these are some of the coolest applications of algorithms in the \"systems\" domain. For example, register allocation uses graph coloring. 2. By understanding how compilers are built and thus how programming languages work, you'll become a better programmer."
   ]
  }
 ],
 "extras": {
  "subject": "CPSC",
  "number": "521",
  "section": 1
 }
}